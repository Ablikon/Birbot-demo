import { ProductModel } from './product.model';
import { ModelType } from '@typegoose/typegoose/lib/types';
import { Types } from 'mongoose';
import { UpdateProductDto, UpdateProductWarehouseDto } from './dto/update-product.dto';
import { StoreService } from 'src/store/store.service';
import { ProductService } from './product.service';
import { Queue } from 'bull';
import { StoreCityService } from 'src/store-city/store-city.service';
import { StoreModel } from 'src/store/store.model';
import { KaspiProductAvailabilityOnPickupPointModel } from './kaspi-product-availability-on-pickup-point.model';
import { ProductMerchantService } from 'src/product-merchant/product-merchant.service';
import { ProductMerchantModel } from 'src/product-merchant/product-merchant.model';
import { KaspiMarketingModel } from 'src/kaspi-marketing/kaspi-marketing.model';
import { KaspiMarketingService } from 'src/kaspi-marketing/kaspi-marketing.service';
export declare class Product {
    private readonly productModel;
    private readonly productMerchantModel;
    private readonly kaspiMarketingModel;
    private readonly kaspiProductAvailabilityOnPickupPointModel;
    private readonly storeService;
    private readonly productService;
    private readonly storeCityService;
    private actualizeProductMerchantsForProductQueue;
    private bonusChangerQueue;
    private dempingTasksForPriceChangeManagerQueue;
    private readonly dempingTasksForPriceParserWithSuperHighPriorityQueue;
    private readonly dempingTasksForProductChangerQueue;
    private readonly dempingTasksForProductChangerManagerQueue;
    private productsWithNewMinPriceQueue;
    private readonly dumpingTasksForPriceChangerQueue;
    private changeProductPriceManuallyQueue;
    private dumpingTasksForManuallyPriceChangeQueue;
    private bonusProductStatusChanger;
    private loadPeriodQueue;
    private readonly productMerchantService;
    private readonly kaspiMarkteingService;
    private readonly techRedisClient;
    constructor(productModel: ModelType<ProductModel>, productMerchantModel: ModelType<ProductMerchantModel>, kaspiMarketingModel: ModelType<KaspiMarketingModel>, kaspiProductAvailabilityOnPickupPointModel: ModelType<KaspiProductAvailabilityOnPickupPointModel>, storeService: StoreService, productService: ProductService, storeCityService: StoreCityService, actualizeProductMerchantsForProductQueue: Queue, bonusChangerQueue: Queue, dempingTasksForPriceChangeManagerQueue: Queue, dempingTasksForPriceParserWithSuperHighPriorityQueue: Queue, dempingTasksForProductChangerQueue: Queue, dempingTasksForProductChangerManagerQueue: Queue, productsWithNewMinPriceQueue: Queue, dumpingTasksForPriceChangerQueue: Queue, changeProductPriceManuallyQueue: Queue, dumpingTasksForManuallyPriceChangeQueue: Queue, bonusProductStatusChanger: Queue, loadPeriodQueue: Queue, productMerchantService: ProductMerchantService, kaspiMarkteingService: KaspiMarketingService);
    updateProduct(productId: string, dto: UpdateProductDto): Promise<any>;
    getJobData(cityId: string, product: any, storeCities: any, store: any, dto: any): Promise<{
        productMerchantId: any;
        productId: any;
        productSku: any;
        masterSku: any;
        storeId: any;
        isDempingOnlyMainCity: any;
        storeName: any;
        mainCityId: any;
        productName: any;
        priceChange: {
            newPrice: any;
            oldPrice: any;
            cityId: string;
        }[];
        additionalCities: any;
        productBrand: any;
    }>;
    actualizeProductAvailabilitiesOnPickupPoints(store: StoreModel, product: ProductModel, productAvailabilityOnPickupPoints: UpdateProductWarehouseDto[]): Promise<void>;
    private validatePrices;
    private addJobToQueueForProductChanger;
    checkActiveProductsLimit(storeId: Types.ObjectId, productsId?: string[]): Promise<void>;
}
